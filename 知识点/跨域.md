```dataview
TABLE this
WHERE file = this.file
```
#web

跨域（Cross-Origin）指的是在[Web应用程序](https://so.csdn.net/so/search?q=Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F&spm=1001.2101.3001.7020)中，一个域的文档或脚本试图请求另一个域的资源，而这两个域的协议、主机或端口不同。由于浏览器的同源策略（Same-Origin Policy）限制，这种跨域的请求通常会被拦截。

比如在3000端口的前端请求8888端口的后端api，就会出现这个问题。

## 1 解决方案

### 1.1 后端解决

在 `SpringSecurityConfig` 中配置

### 1.2 前端解决

设置代理

```js
const { createProxyMiddleware } = require('http-proxy-middleware');

  

module.exports = function(app) {

  console.log('设置代理中间件...');

  // 配置代理

  app.use(

    '/auth', // 所有以/auth开头的请求

    createProxyMiddleware({

      target: 'http://localhost:8888', // 代理目标服务器

      changeOrigin: true, // 改变请求头中的Origin

      secure: false, // 接受无效证书

      // 添加必要的请求头

      onProxyReq: function(proxyReq, req, res) {

        proxyReq.setHeader('platform', 'web');

        proxyReq.setHeader('version', '1.0.0');

        console.log(`代理请求: ${req.method} ${req.url}`);

      },

      // 处理代理响应

      onProxyRes: function(proxyRes, req, res) {

        console.log(`代理响应: ${req.method} ${req.url} -> ${proxyRes.statusCode}`);

        // 如果是OPTIONS请求，确保返回正确的CORS头

        if (req.method === 'OPTIONS') {

          proxyRes.headers['Access-Control-Allow-Origin'] = '*';

          proxyRes.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS';

          proxyRes.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization, platform, version';

          proxyRes.headers['Access-Control-Max-Age'] = '3600';

        }

      },

      // 处理错误

      onError: function(err, req, res) {

        console.error(`代理错误: ${req.method} ${req.url}`, err);

        res.writeHead(500, {

          'Content-Type': 'text/plain'

        });

        res.end('代理请求出错');

      },

      logLevel: 'debug' // 调试模式

    })

  );

};
```